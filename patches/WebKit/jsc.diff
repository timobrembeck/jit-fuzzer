diff --git a/Source/JavaScriptCore/jsc.cpp b/Source/JavaScriptCore/jsc.cpp
index 83ca231719..5fc8e9eb61 100644
--- a/Source/JavaScriptCore/jsc.cpp
+++ b/Source/JavaScriptCore/jsc.cpp
@@ -65,10 +65,12 @@
 #include "TestRunnerUtils.h"
 #include "TypedArrayInlines.h"
 #include "VMInspector.h"
 #include "WasmCapabilities.h"
 #include "WasmMemory.h"
+#include <fuzzer/FuzzedDataProvider.h> // fuzzed data provider for splitting afl input
+#include <map> // map for fuzzing data type sizes
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -352,10 +354,13 @@
 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*);
 
 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject*, CallFrame*);
 static EncodedJSValue JSC_HOST_CALL functionAsDoubleNumber(JSGlobalObject*, CallFrame*);
 
+// Custom function for receiving afl input
+static EncodedJSValue JSC_HOST_CALL functionGetAFLInputArray(JSGlobalObject*, CallFrame*);
+
 struct Script {
     enum class StrictMode {
         Strict,
         Sloppy
     };
@@ -621,10 +626,13 @@
         addFunction(vm, "totalCompileTime", functionTotalCompileTime, 0);
 
         addFunction(vm, "setUnhandledRejectionCallback", functionSetUnhandledRejectionCallback, 1);
 
         addFunction(vm, "asDoubleNumber", functionAsDoubleNumber, 1);
+
+        // Custom function for receiving afl input
+        addFunction(vm, "getAFLInputArray", functionGetAFLInputArray, 1);
     }
     
     void addFunction(VM& vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
     {
         Identifier identifier = Identifier::fromString(vm, name);
@@ -2481,10 +2489,97 @@
     double num = callFrame->argument(0).toNumber(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     return JSValue::encode(jsDoubleNumber(num));
 }
 
+// Custom function for receiving afl input
+EncodedJSValue JSC_HOST_CALL functionGetAFLInputArray(JSGlobalObject* globalObject, CallFrame* callFrame) {
+
+    // debug output
+    fprintf(stderr, "##########################################################################################\n");
+
+    // initialize global objects
+    VM& vm = globalObject->vm();
+    Structure* structure = globalObject->restParameterStructure();
+
+    // initialize data type sizes
+    std::map<std::string, int> data_type_sizes;
+    data_type_sizes["bool"] = 1;
+    data_type_sizes["integer"] = 2;
+    data_type_sizes["double"] = 8;
+    data_type_sizes["string"] = 10; // only handle strings up to 10 bytes
+
+    // array of input types which are requested from JS (cast from JSValue to JSArray)
+    JSArray* afl_input_types_js = jsCast<JSArray*>(callFrame->argument(0));
+
+    // number of inputs which are requested from JS
+    int afl_input_types_length = afl_input_types_js->length();
+
+    // cumulated size of all requested input types in bytes
+    int afl_input_size = 0;
+
+    // convert JSArray 'afl_input_types_js' to C++ string array 'afl_input_types'
+    std::string afl_input_types[afl_input_types_length];
+    for (size_t i = 0; i < afl_input_types_length; ++i) {
+        std::string afl_input_type = afl_input_types_js->pop(globalObject).toString(globalObject)->value(globalObject).utf8().data();
+        // reverse order because pop() returns the last element first
+        afl_input_types[afl_input_types_length - i - 1] = afl_input_type;
+        afl_input_size += data_type_sizes[afl_input_type];
+    }
+
+    // print requested afl input types
+    fprintf(stderr, "[JSC] Requested AFL input types: ");
+    for (size_t i = 0; i < afl_input_types_length; ++i) fprintf(stderr, "%s, ", afl_input_types[i].c_str());
+    fprintf(stderr, "\n");
+
+    // print requested afl input size
+    fprintf(stderr, "[JSC] Cumulated size of requested afl input: %d\n", afl_input_size);
+
+    // initialize buffer for afl input
+    const unsigned char *afl_input;
+    afl_input = (unsigned char *) malloc(afl_input_size * sizeof(char));
+
+    // fill afl buffer by calling custom syscall
+    int success = syscall(536, afl_input, afl_input_size);
+    if (success != EXIT_SUCCESS) {
+        exit(1);
+    }
+
+    // print afl input
+    fprintf(stderr, "[JSC]  AFL input: ");
+    for (size_t i = 0; i < afl_input_size; ++i) fprintf(stderr, "%02x ", afl_input[i]);
+    fprintf(stderr, "\n");
+
+    // initialize fuzzed data provider (FDL) - see https://github.com/google/fuzzing/blob/master/docs/split-inputs.md
+    FuzzedDataProvider fuzzed_data(afl_input, afl_input_size);
+
+    // initialize return array
+    JSArray* afl_input_array = JSArray::tryCreate(vm, structure, afl_input_types_length);
+
+    // fill return array
+    for (size_t i = 0; i < afl_input_types_length; ++i) {
+        if (afl_input_types[i] == "bool"){
+            bool afl_input_bool = fuzzed_data.ConsumeBool();
+            afl_input_array->putDirectIndex(globalObject, i, jsBoolean(afl_input_bool));
+        } else if (afl_input_types[i] == "integer"){
+            int afl_input_integer = fuzzed_data.ConsumeIntegral<uint16_t>();
+            afl_input_array->putDirectIndex(globalObject, i, jsNumber(afl_input_integer));
+        } else if (afl_input_types[i] == "double"){
+            double afl_input_double = fuzzed_data.ConsumeFloatingPoint<double>();
+            afl_input_array->putDirectIndex(globalObject, i, jsDoubleNumber(afl_input_double));
+        } else if (afl_input_types[i] == "string"){
+            std::string afl_input_string = fuzzed_data.ConsumeRandomLengthString(10);
+            afl_input_array->putDirectIndex(globalObject, i, JSC::JSValue(JSC::jsString(vm, WTF::String(afl_input_string.c_str()))));
+        } else {
+            afl_input_array->putDirectIndex(globalObject, i, jsUndefined());
+        }
+    }
+
+    // return array with random values to js
+    return JSValue::encode(afl_input_array);
+}
+
 // Use SEH for Release builds only to get rid of the crash report dialog
 // (luckily the same tests fail in Release and Debug builds so far). Need to
 // be in a separate main function because the jscmain function requires object
 // unwinding.
 
